-- difference from TheDiveV1: fires remote instead of clicking for receives & no longer relies on the camera being on the setter, resulting in more accurate receives.

local TeamNameOk = ""

local VirtualInputManager = Instance.new('VirtualInputManager')
local mouse = game.Players.LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera

-- Save original FOV and set to 90
local originalFOV = Camera.FieldOfView
local fovConnection = nil
Camera.FieldOfView = 90

-- Monitor FOV changes and reset to 90 whenever it changes
fovConnection = Camera:GetPropertyChangedSignal("FieldOfView"):Connect(function()
    if Camera.FieldOfView ~= 90 then
        Camera.FieldOfView = 90
    end
end)

-- Add toggle state
local autoEnabled = false
local eastSideCrytToggle = false
local aimLockEnabled = false
local rallyAutoEnabled = false
local servingMode = false
local previousSetter = nil
local aimLockStateBeforeServing = false -- Remember aimLock state before serving mode was enabled

local function LeftClick()
    VirtualInputManager:SendMouseButtonEvent(mouse.X, mouse.Y, 0, true, game, 0)
    task.wait(0.1) -- make 0.1 if too skibidi
    VirtualInputManager:SendMouseButtonEvent(mouse.X, mouse.Y, 0, false, game, 0)
end

local function ActivateDive()
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
end


--------------------------------------------------------------------------------------------------------------------

-- Services
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")

-- Local Player
local LocalPlayer = Players.LocalPlayer
local AliveFolder = workspace:WaitForChild("Alive Folder")
local LocalModel = AliveFolder:WaitForChild(LocalPlayer.Name)
local PassChargeMeter = LocalModel:WaitForChild("PassChargeMeter")
local Humanoid = LocalModel:WaitForChild("Humanoid")
local SpikeChargeMeter = LocalModel:WaitForChild("SpikeChargeMeter")

-- State Manager UI
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local stateManagerGui = Instance.new("ScreenGui")
stateManagerGui.Name = "StateManagerUI"
stateManagerGui.ResetOnSpawn = false
stateManagerGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
stateManagerGui.Parent = PlayerGui

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 250, 0, 140) -- Increased height for Auto Rally label
mainFrame.Position = UDim2.new(1, -300, 1, -265)
mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
mainFrame.BackgroundTransparency = 0.3
mainFrame.BorderSizePixel = 0
mainFrame.Parent = stateManagerGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 8)
uiCorner.Parent = mainFrame

local uiStroke = Instance.new("UIStroke")
uiStroke.Color = Color3.fromRGB(100, 100, 100)
uiStroke.Thickness = 2
uiStroke.Parent = mainFrame

local uiPadding = Instance.new("UIPadding")
uiPadding.PaddingLeft = UDim.new(0, 10)
uiPadding.PaddingRight = UDim.new(0, 10)
uiPadding.PaddingTop = UDim.new(0, 10)
uiPadding.PaddingBottom = UDim.new(0, 10)
uiPadding.Parent = mainFrame

local uiListLayout = Instance.new("UIListLayout")
uiListLayout.Padding = UDim.new(0, 5)
uiListLayout.FillDirection = Enum.FillDirection.Vertical
uiListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
uiListLayout.VerticalAlignment = Enum.VerticalAlignment.Top
uiListLayout.Parent = mainFrame

-- Helper function to create state label
local function createStateLabel(text: string)
    local label = Instance.new("TextLabel")
    label.Name = text:gsub(" ", "")
    label.Size = UDim2.new(1, 0, 0, 20)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 14
    label.Font = Enum.Font.Gotham
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    label.Parent = mainFrame
    return label
end

-- Create state labels with base text storage
local labelBaseTexts = {}
local autoSystemLabel = createStateLabel("Auto System: OFF")
labelBaseTexts[autoSystemLabel] = "Auto System"
local aimlockLabel = createStateLabel("Aimlock: OFF")
labelBaseTexts[aimlockLabel] = "Aimlock"
local servingModeLabel = createStateLabel("Serving Mode: OFF")
labelBaseTexts[servingModeLabel] = "Serving Mode"
local autoRallyLabel = createStateLabel("Auto Rally: OFF")
labelBaseTexts[autoRallyLabel] = "Auto Rally"

-- Create setter container with text and avatar
local setterContainer = Instance.new("Frame")
setterContainer.Name = "SetterContainer"
setterContainer.Size = UDim2.new(1, 0, 0, 20)
setterContainer.BackgroundTransparency = 1
setterContainer.Parent = mainFrame

local setterLabel = Instance.new("TextLabel")
setterLabel.Name = "SetterLabel"
setterLabel.Size = UDim2.new(1, -25, 1, 0) -- Leave space for avatar
setterLabel.Position = UDim2.new(0, 0, 0, 0)
setterLabel.BackgroundTransparency = 1
setterLabel.Text = "Setter: N/A"
setterLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
setterLabel.TextSize = 14
setterLabel.Font = Enum.Font.Gotham
setterLabel.TextXAlignment = Enum.TextXAlignment.Left
setterLabel.TextYAlignment = Enum.TextYAlignment.Center
setterLabel.Parent = setterContainer

local setterAvatar = Instance.new("ImageLabel")
setterAvatar.Name = "SetterAvatar"
setterAvatar.Size = UDim2.new(0, 18, 0, 18)
setterAvatar.Position = UDim2.new(1, -18, 0, 1)
setterAvatar.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
setterAvatar.BorderSizePixel = 0
setterAvatar.BackgroundTransparency = 0.3
setterAvatar.Image = "" -- Will be set when setter is selected
setterAvatar.ImageTransparency = 1 -- Hidden by default
setterAvatar.Parent = setterContainer

local avatarCorner = Instance.new("UICorner")
avatarCorner.CornerRadius = UDim.new(0, 3)
avatarCorner.Parent = setterAvatar

-- Function to update state labels with colored ON/OFF
local function updateStateLabel(label: TextLabel, state: boolean)
    local baseText = labelBaseTexts[label]
    if not baseText then
        -- Fallback: extract from current text (strip RichText tags if present)
        baseText = label.Text:gsub(":.*", ""):gsub("<[^>]+>", "")
        labelBaseTexts[label] = baseText
    end
    
    local newText = baseText .. ": "
    
    if state then
        -- Use green color for ON
        newText = newText .. '<font color="#00FF00">ON</font>'
    else
        -- Use red color for OFF
        newText = newText .. '<font color="#FF0000">OFF</font>'
    end
    
    label.Text = newText
    label.RichText = true
end

-- Function to update all UI states (defined after selectedSetter to ensure proper closure)

-- Dive System Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RSPackageFolder = ReplicatedStorage:WaitForChild("RSPackageFolder")
local Mechanics = RSPackageFolder:WaitForChild("Mechanics")
local DiveRemote = Mechanics:WaitForChild("Dive")
local PassRemote = Mechanics:WaitForChild("Pass")
local Animations = RSPackageFolder:WaitForChild("Animations")
local Stamina = LocalPlayer.PlayerScripts:WaitForChild("Stamina")
local Animator = Humanoid:FindFirstChildWhichIsA("Animator")

-- Load Dive Animations
local DiveAnim = Animator:LoadAnimation(Animations:WaitForChild("Dive"))
local DiveLeftAnim = Animator:LoadAnimation(Animations:WaitForChild("DiveLeft"))
local DiveRightAnim = Animator:LoadAnimation(Animations:WaitForChild("DiveRight"))
local DiveBackAnim = Animator:LoadAnimation(Animations:WaitForChild("DiveBack"))
local DiveBackLeftAnim = Animator:LoadAnimation(Animations:WaitForChild("DiveBackLeft"))
local DiveBackRightAnim = Animator:LoadAnimation(Animations:WaitForChild("DiveBackRight"))
local DiveFrontLeftAnim = Animator:LoadAnimation(Animations:WaitForChild("DiveFrontLeft"))
local DiveFrontRightAnim = Animator:LoadAnimation(Animations:WaitForChild("DiveFrontRight"))

-- Load Pass Animations
local PassStanceAnim = Animator:LoadAnimation(Animations:WaitForChild("PassStance"))
local BumpAnim = Animator:LoadAnimation(Animations:WaitForChild("Bump"))

-- Set animation properties
PassStanceAnim.Priority = Enum.AnimationPriority.Idle
PassStanceAnim.Looped = true
BumpAnim.Priority = Enum.AnimationPriority.Action2
BumpAnim.Looped = false

-- Fast guard: don't auto-dive if we're already in a dive animation
local DIVE_ANIM_TRACKS = {
	DiveAnim,
	DiveLeftAnim,
	DiveRightAnim,
	DiveBackAnim,
	DiveBackLeftAnim,
	DiveBackRightAnim,
	DiveFrontLeftAnim,
	DiveFrontRightAnim,
}

local function isAnyDiveAnimPlaying(): boolean
	-- Using the same loaded tracks is the cheapest check (no GetPlayingAnimationTracks calls)
	for _, track in ipairs(DIVE_ANIM_TRACKS) do
		if track and track.IsPlaying then
			return true
		end
	end
	return false
end

-- Set animation priorities
DiveAnim.Priority = Enum.AnimationPriority.Action2
DiveLeftAnim.Priority = Enum.AnimationPriority.Action2
DiveRightAnim.Priority = Enum.AnimationPriority.Action2
DiveBackAnim.Priority = Enum.AnimationPriority.Action2
DiveBackLeftAnim.Priority = Enum.AnimationPriority.Action2
DiveBackRightAnim.Priority = Enum.AnimationPriority.Action2
DiveFrontLeftAnim.Priority = Enum.AnimationPriority.Action2
DiveFrontRightAnim.Priority = Enum.AnimationPriority.Action2

--------------------------------------------------------------------------------------------------------------------

-- Calculate dive direction based on target position relative to player's facing direction
-- Returns: diveType (for server), diveDirection (Vector3), animationType (for animation selection)
local function calculateDiveDirection(targetPosition: Vector3): (string, Vector3, string)
    local humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        return "FrontDive", Vector3.new(0, 0, 0), "FrontDive"
    end
    
    local playerPosition = humanoidRootPart.Position
    local lookVector = humanoidRootPart.CFrame.LookVector
    local rightVector = humanoidRootPart.CFrame.RightVector
    
    -- Calculate direction to target (horizontal only)
    local toTarget = (targetPosition - playerPosition)
    toTarget = Vector3.new(toTarget.X, 0, toTarget.Z).Unit
    
    -- Calculate dot products
    local forwardDot = toTarget:Dot(lookVector)
    local rightDot = toTarget:Dot(rightVector)
    
    local diveType = "FrontDive"  -- This is what gets sent to server
    local diveDirection = lookVector
    local animationType = "FrontDive"  -- This determines which animation to play
    
    -- Determine dive direction based on dot products (matches MechanicsClient logic)
    if forwardDot > 0.5 then
        -- Front direction - always send "FrontDive" to server
        diveType = "FrontDive"
        diveDirection = toTarget  -- Use actual direction to target
        
        -- But select animation based on right component
        if rightDot > 0.5 then
            animationType = "FrontRightDive"
        elseif rightDot < -0.5 then
            animationType = "FrontLeftDive"
        else
            animationType = "FrontDive"
        end
    elseif forwardDot < -0.5 then
        -- Back direction - always send "BackDive" to server
        diveType = "BackDive"
        diveDirection = toTarget  -- Use actual direction to target
        
        -- But select animation based on right component
        if rightDot > 0.5 then
            animationType = "BackRightDive"
        elseif rightDot < -0.5 then
            animationType = "BackLeftDive"
        else
            animationType = "BackDive"
        end
    elseif rightDot > 0.75 then
        -- Right direction
        diveType = "RightDive"
        animationType = "RightDive"
        diveDirection = rightVector
    elseif rightDot < -0.75 then
        -- Left direction
        diveType = "LeftDive"
        animationType = "LeftDive"
        diveDirection = -rightVector
    else
        -- Default to front
        diveType = "FrontDive"
        animationType = "FrontDive"
        diveDirection = lookVector
    end
    
    return diveType, diveDirection, animationType
end

--------------------------------------------------------------------------------------------------------------------

-- Dive system variables (must be defined before performDirectionalDive function)
local diveDebounce = false
local activeDiveAttachment = nil
local activeDiveLinearVelocity = nil
local activeDiveConnection = nil
local lastDiveTime = 0
local DIVE_COOLDOWN = 0.1 -- Minimum time between dives (in seconds)

-- Perform directional dive with physics
local function performDirectionalDive(targetPosition: Vector3)
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    
    if not humanoidRootPart or not humanoid then return end
    
    -- Check prerequisites - set debounce IMMEDIATELY to prevent multiple calls
    local currentTime = tick()
    if diveDebounce then return end
    if isAnyDiveAnimPlaying() then return end
    if (currentTime - lastDiveTime) < DIVE_COOLDOWN then return end
    if humanoid.FloorMaterial == Enum.Material.Air then return end
    if character:HasTag("APPROACHING") then return end
    if Stamina.Value < 10 then return end
    
    -- Update last dive time immediately
    lastDiveTime = currentTime
    
    -- Check for existing dive objects and clean them up first
    if activeDiveConnection then
        activeDiveConnection:Disconnect()
        activeDiveConnection = nil
    end
    if activeDiveLinearVelocity then
        activeDiveLinearVelocity:Destroy()
        activeDiveLinearVelocity = nil
    end
    if activeDiveAttachment then
        activeDiveAttachment:Destroy()
        activeDiveAttachment = nil
    end
    
    -- Also check for any leftover LinearVelocity/Attachment objects
    for _, child in ipairs(humanoidRootPart:GetChildren()) do
        if child:IsA("LinearVelocity") or child:IsA("Attachment") then
            if child.Name == "Attachment" or child.Name == "LinearVelocity" or child.Parent == humanoidRootPart then
                child:Destroy()
            end
        end
    end
    
    -- Set debounce IMMEDIATELY before any async operations
    diveDebounce = true
    
    -- Calculate direction directly to target position (for LinearVelocity)
    local playerPosition = humanoidRootPart.Position
    local toTarget = (targetPosition - playerPosition)
    local horizontalToTarget = Vector3.new(toTarget.X, 0, toTarget.Z)
    local directDiveDirection = horizontalToTarget.Unit  -- Direct direction to FinalPosition
    
    -- Calculate which animation/event to use based on closest matching direction
    local diveType, _, animationType = calculateDiveDirection(targetPosition)
    
    -- Calculate dive velocity
    local currentVelocity = humanoidRootPart.AssemblyLinearVelocity
    local horizontalVelocity = Vector3.new(currentVelocity.X, 0, currentVelocity.Z)
    local velocityMagnitude = horizontalVelocity.Magnitude
    local diveSpeed = 300 * (1 + velocityMagnitude / 100)
    
    -- Apply DIVELENGTH attribute if exists
    if LocalPlayer:GetAttribute("DIVELENGTH") then
        diveSpeed = diveSpeed * LocalPlayer:GetAttribute("DIVELENGTH")
    end
    
    -- Deduct stamina
    Stamina.Value = Stamina.Value - 10
    
    -- Create physics objects
    local attachment = Instance.new("Attachment", humanoidRootPart)
    attachment.Name = "DiveAttachment"
    local linearVelocity = Instance.new("LinearVelocity", humanoidRootPart)
    linearVelocity.Name = "DiveLinearVelocity"
    linearVelocity.Attachment0 = attachment
    linearVelocity.ForceLimitMode = Enum.ForceLimitMode.PerAxis
    linearVelocity.MaxAxesForce = Vector3.new(30000, 0, 30000)
    -- Use direct direction to FinalPosition for actual movement
    linearVelocity.VectorVelocity = directDiveDirection * diveSpeed
    
    -- Store references
    activeDiveAttachment = attachment
    activeDiveLinearVelocity = linearVelocity
    
    -- Play appropriate animation based on animationType (not diveType)
    -- This allows diagonal animations while still sending "FrontDive"/"BackDive" to server
    local animationToPlay = DiveAnim
    if animationType == "LeftDive" then
        animationToPlay = DiveLeftAnim
    elseif animationType == "RightDive" then
        animationToPlay = DiveRightAnim
    elseif animationType == "BackDive" then
        animationToPlay = DiveBackAnim
    elseif animationType == "BackLeftDive" then
        animationToPlay = DiveBackLeftAnim
    elseif animationType == "BackRightDive" then
        animationToPlay = DiveBackRightAnim
    elseif animationType == "FrontLeftDive" then
        animationToPlay = DiveFrontLeftAnim
    elseif animationType == "FrontRightDive" then
        animationToPlay = DiveFrontRightAnim
    end
    
    animationToPlay:Play()
    
    -- Fire remote event
    DiveRemote:FireServer(diveType)
    
    -- Set up deceleration loop (matches MechanicsClient formula)
    local decelConnection
    decelConnection = RunService.RenderStepped:Connect(function(deltaTime)
        -- Check if objects still exist
        if not linearVelocity or not linearVelocity.Parent then
            if decelConnection then
                decelConnection:Disconnect()
            end
            return
        end
        local currentVel = linearVelocity.VectorVelocity
        local velMagnitude = currentVel.Magnitude
        
        -- Stop deceleration if velocity is very low
        if velMagnitude < 1 then
            linearVelocity.VectorVelocity = Vector3.new(0, 0, 0)
            if decelConnection then
                decelConnection:Disconnect()
            end
            return
        end
        
        -- Formula from MechanicsClient: v129 - v129 * (0.15 * (60 / (1 / p128)))
        -- where p128 is deltaTime, so: 60 / (1 / deltaTime) = 60 * deltaTime
        -- At 60 FPS, deltaTime = 1/60, so 60 * (1/60) = 1
        -- This reduces velocity by 15% per frame
        linearVelocity.VectorVelocity = currentVel - currentVel * (0.15 * (60 * deltaTime))
    end)
    
    -- Store connection reference
    activeDiveConnection = decelConnection
    
    -- Check for SWIFT RECOVERY weapon
    local weapon1 = LocalPlayer:GetAttribute("WEAPON")
    local weapon2 = LocalPlayer:GetAttribute("WEAPON_2")
    local hasSwiftRecovery = (weapon1 == "SWIFT RECOVERY" and LocalPlayer:GetAttribute("WEAPONPROC")) or 
                             (weapon2 == "SWIFT RECOVERY" and LocalPlayer:GetAttribute("WEAPONPROC_2"))
    
    -- Clean up after dive duration (synchronous like MechanicsClient)
    task.spawn(function()
        -- Wait for dive duration
        task.wait(hasSwiftRecovery and 0.2 or 1.0)
        
        -- Disconnect deceleration loop FIRST
        if activeDiveConnection then
            activeDiveConnection:Disconnect()
            activeDiveConnection = nil
        end
        
        -- Stop animation
        if animationToPlay then
            animationToPlay:Stop()
        end
        
        -- Zero out velocity before destroying (safety measure)
        if activeDiveLinearVelocity and activeDiveLinearVelocity.Parent then
            activeDiveLinearVelocity.VectorVelocity = Vector3.new(0, 0, 0)
            activeDiveLinearVelocity:Destroy()
            activeDiveLinearVelocity = nil
        end
        if activeDiveAttachment and activeDiveAttachment.Parent then
            activeDiveAttachment:Destroy()
            activeDiveAttachment = nil
        end
        
        -- Failsafe: Clean up any remaining LinearVelocity/Attachment objects
        if humanoidRootPart and humanoidRootPart.Parent then
            for _, child in ipairs(humanoidRootPart:GetChildren()) do
                if (child:IsA("LinearVelocity") and (child.Name == "DiveLinearVelocity" or child == linearVelocity)) or
                   (child:IsA("Attachment") and (child.Name == "DiveAttachment" or child == attachment)) then
                    if child:IsA("LinearVelocity") then
                        child.VectorVelocity = Vector3.new(0, 0, 0)
                    end
                    child:Destroy()
                end
            end
        end
        
        -- Reset debounce after additional delay (matches MechanicsClient)
        task.wait(hasSwiftRecovery and 0.2 or 1.0)
        diveDebounce = false
    end)
end

--------------------------------------------------------------------------------------------------------------------

local net
if game.PlaceId == 17435076424 then -- Park Gym
    net = workspace.FunctionalityHitboxes.CourtA.Net
elseif game.PlaceId == 17516264439 then -- Haikyu Gym
    net = workspace.Net
elseif game.PlaceId == 80022670470204 then -- Beach Gym
    net = workspace.MAP.CourtA.Net
else
    net = workspace.NetUtilities.Net -- Nationals Gym
end

local InHitbox
if game.PlaceId == 17435076424 then -- Park Gym
    InHitbox = workspace.FunctionalityHitboxes.InHitbox
elseif game.PlaceId == 17516264439 then -- Haikyu Gym
    InHitbox = workspace.InHitbox
else 
    InHitbox = workspace.InHitbox
end

--------------------------------------------------------------------------------------------------------------------

-- Variables
local selectedSetter = nil
local aimLock = false
local debounce = false
local scriptActive = true
local moveToWalkSpeedSet = false
local moveToWalkSpeedConnection = nil
local speedLoopConnection = nil
local characterAddedConnection = nil
local readjusting = false
local mouseButton1Held = false
local mouseButton1ReleaseTime = 0
local MOUSE_BUTTON_1_POST_RELEASE_DURATION = 0.3 -- Fire remote for 0.3s after release
local passDebounce = false -- Prevent spamming pass animations
local hold = false -- MouseButton2 hold state

-- Track current setter user ID to avoid reloading avatar unnecessarily
local currentSetterUserId = nil

-- Function to update all UI states (defined after selectedSetter to ensure proper closure)
local function updateStateManagerUI()
    updateStateLabel(autoSystemLabel, autoEnabled)
    updateStateLabel(aimlockLabel, aimLockEnabled)
    updateStateLabel(servingModeLabel, servingMode)
    updateStateLabel(autoRallyLabel, rallyAutoEnabled)
    
    -- Same check as the notification - just use selectedSetter.Name directly
    if selectedSetter then
        setterLabel.Text = "Setter: " .. selectedSetter.Name
        setterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        
        -- Load avatar if setter changed
        local setterUserId = selectedSetter.UserId
        if setterUserId ~= currentSetterUserId then
            currentSetterUserId = setterUserId
            setterAvatar.ImageTransparency = 1 -- Hide while loading
            
            -- Load avatar thumbnail asynchronously
            task.spawn(function()
                local success, thumbnail = pcall(function()
                    return Players:GetUserThumbnailAsync(setterUserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150)
                end)
                
                if success and thumbnail and setterAvatar and setterAvatar.Parent then
                    setterAvatar.Image = thumbnail
                    setterAvatar.ImageTransparency = 0
                end
            end)
        else
            -- Avatar already loaded, just make sure it's visible
            if setterAvatar.Image ~= "" then
                setterAvatar.ImageTransparency = 0
            end
        end
    else
        setterLabel.Text = "Setter: N/A"
        setterLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        setterAvatar.ImageTransparency = 1 -- Hide avatar when no setter
        currentSetterUserId = nil
    end
end

-- Update UI on RenderStepped to ensure it's always current (after selectedSetter is declared)
RunService:BindToRenderStep("UpdateStateManagerUI", Enum.RenderPriority.Last.Value, function()
    updateStateManagerUI()
end)

--------------------------------------------------------------------------------------------------------------------

-- Custom Power Bar UI (only shows during receives/autodives) - matches original ShotBar properties
local powerBarGui = Instance.new("ScreenGui")
powerBarGui.Name = "CustomPowerBar"
powerBarGui.ResetOnSpawn = false
powerBarGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
powerBarGui.Parent = PlayerGui

local powerBarParent = Instance.new("Frame")
powerBarParent.Name = "ShotBar"
powerBarParent.AnchorPoint = Vector2.new(0.5, 0.5)
powerBarParent.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
powerBarParent.BackgroundTransparency = 1
powerBarParent.BorderColor3 = Color3.fromRGB(27, 42, 53)
powerBarParent.BorderMode = Enum.BorderMode.Outline
powerBarParent.BorderSizePixel = 1
powerBarParent.LayoutOrder = 0
powerBarParent.Position = UDim2.new(0.5, 0, 0.5, -20)
powerBarParent.Size = UDim2.new(0, 40, 0, 6)
powerBarParent.SizeConstraint = Enum.SizeConstraint.RelativeXY
powerBarParent.ZIndex = 1
powerBarParent.Visible = false
powerBarParent.Parent = powerBarGui

local backbar = Instance.new("Frame")
backbar.Name = "backbar"
backbar.AnchorPoint = Vector2.new(0, 0)
backbar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
backbar.BackgroundTransparency = 0.5
backbar.BorderColor3 = Color3.fromRGB(27, 42, 53)
backbar.BorderMode = Enum.BorderMode.Outline
backbar.BorderSizePixel = 1
backbar.Position = UDim2.new(0, 0, 0, -3)
backbar.Size = UDim2.new(0, 40, 0, 6)
backbar.ZIndex = 2 -- In front of shotbar
backbar.Parent = powerBarParent

local shotbar = Instance.new("Frame")
shotbar.Name = "Shotbar"
shotbar.AnchorPoint = Vector2.new(0, 0)
shotbar.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
shotbar.BackgroundTransparency = 0.2
shotbar.BorderColor3 = Color3.fromRGB(27, 42, 53)
shotbar.BorderMode = Enum.BorderMode.Outline
shotbar.BorderSizePixel = 1
shotbar.Size = UDim2.new(0, 0, -1, 0)
shotbar.Position = UDim2.new(0, 0, -2, 0)
shotbar.ZIndex = 1 -- Behind backbar
shotbar.Parent = powerBarParent

-- Power bar state
local isPowerBarCharging = false
local targetPowerValue = 0
local maxCharge = PassChargeMeter:GetAttribute("MaxCharge") or 150
local powerBarAnimationConnection = nil

-- Function to show and animate power bar
local function showPowerBar(powerValue: number)
    -- Don't restart animation if already charging
    if isPowerBarCharging then
        -- Just update target value for color, but don't restart animation
        targetPowerValue = math.clamp(powerValue, 0, maxCharge)
        return
    end
    
    -- Disconnect any existing animation
    if powerBarAnimationConnection then
        powerBarAnimationConnection:Disconnect()
        powerBarAnimationConnection = nil
    end
    
    targetPowerValue = math.clamp(powerValue, 0, maxCharge)
    powerBarParent.Visible = true
    isPowerBarCharging = true
    
    -- Reset bar to 0 (matching original LocalScript format)
    shotbar.Size = UDim2.new(0, 0, -1, 0)
    shotbar.Position = UDim2.new(0, 0, -2, 0)
    backbar.Position = UDim2.new(0, 0, -3, 0)
    shotbar.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Start with green (min power)
    
    -- Calculate target clamped value
    local targetClamped = math.clamp(targetPowerValue / maxCharge, 0 / maxCharge, 1)
    
    -- Color interpolation values
    local greenColor = Color3.fromRGB(0, 255, 0) -- Min power color
    local redColor = Color3.fromRGB(255, 0, 0) -- Max power color
    
    -- Animate both size and color continuously
    local chargeStartTime = tick()
    local chargeDuration = 0.25 -- Charge duration
    
    powerBarAnimationConnection = RunService.RenderStepped:Connect(function()
        if not isPowerBarCharging or not powerBarParent or not powerBarParent.Parent then
            if powerBarAnimationConnection then
                powerBarAnimationConnection:Disconnect()
                powerBarAnimationConnection = nil
            end
            return
        end
        
        local currentTime = tick()
        local elapsed = currentTime - chargeStartTime
        local progress = math.min(elapsed / chargeDuration, 1)
        
        -- Ease-out cubic for smooth animation
        local easedProgress = 1 - math.pow(1 - progress, 3)
        
        -- Current clamped value (interpolated from 0 to target)
        local currentClamped = targetClamped * easedProgress
        
        -- Update size continuously
        shotbar.Size = UDim2.new(currentClamped, 0, -1, 0)
        
        -- Update color continuously based on current power level
        shotbar.BackgroundColor3 = Color3.new(
            greenColor.R + (redColor.R - greenColor.R) * currentClamped,
            greenColor.G + (redColor.G - greenColor.G) * currentClamped,
            greenColor.B + (redColor.B - greenColor.B) * currentClamped
        )
        
        -- When animation completes
        if progress >= 1 then
            if powerBarAnimationConnection then
                powerBarAnimationConnection:Disconnect()
                powerBarAnimationConnection = nil
            end
            
            -- Wait a bit then hide
            task.wait(0.15)
            if powerBarParent then
                powerBarParent.Visible = false
                isPowerBarCharging = false
            end
        end
    end)
end

-- Function to hide power bar immediately
local function hidePowerBar()
    if powerBarAnimationConnection then
        powerBarAnimationConnection:Disconnect()
        powerBarAnimationConnection = nil
    end
    if powerBarParent then
        powerBarParent.Visible = false
        isPowerBarCharging = false
    end
end

-- Helper function to get XZ (horizontal) component of a Vector3 (like crytimperium)
local function XZ(V)
    return Vector3.new(V.X, 0, V.Z)
end

local function calculatePassingPower(setterPosition)
    -- Use crytimperium's formula: 0.936501 * distance + 33.02382
    local myPos = LocalPlayer.Character.HumanoidRootPart.Position
    local distance = (XZ(myPos - setterPosition)).Magnitude
    local value = 0.936501 * distance + 33.02382
    
    -- Minimum value check (like crytimperium)
    if value < 4 then
        value = 4
    end
    
    -- Reduce power if within 30 studs (like crytimperium)
    local fullDistance = (myPos - setterPosition).Magnitude
    if fullDistance <= 30 then
        value = value - 10
    end
    
    return math.clamp(value, 0, 150)
end

-- Quadratic version for EastSideCryt passing power
local function calculatePassingPowerEastSideCryt(distance)
    return (0.005 * distance^2) + (0.9 * distance) + 30 -- Slightly higher power
end
--[[
-- Function to calculate passing power using a predefined linear equation
local function calculatePassingPower(distance)
    local netDistance = (LocalPlayer.Character.HumanoidRootPart.Position - net.Position).Magnitude
    local value
    if netDistance <= 10 then
        value = 0.7 * (0.936501 * distance + 33.02382) -- Reduce power significantly if within 7 studs of the net
    else
        value = 0.936501 * distance + 33.02382 -- -- value = 1.036501 * distance + 38.02382
    end
    return math.clamp(value, 0, 150) -- Ensure the value stays within valid range
end

local function calculatePassingPowerEastSideCryt(distance)
    return 0.936501 * distance + 41.02382
end
--]]
--------------------------------------------------------------------------------------------------------------------

-- Function to get the nearest player
local function getNearestPlayer()
    local nearestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlayer = player
            end
        end
    end

    return nearestPlayer
end

--------------------------------------------------------------------------------------------------------------------

-- Function to update the PassChargeMeter
local passActive = true

-- Cleanup function for script termination (defined early so it can be called from End handlers)
local function terminateScript()
    RunService:UnbindFromRenderStep("UpdateChargeMeters")
    RunService:UnbindFromRenderStep("UpdateBallSizes")
    RunService:UnbindFromRenderStep("CheckRallyAuto")
    RunService:UnbindFromRenderStep("UpdatePassChargeMeter")
    RunService:UnbindFromRenderStep("UpdateStateManagerUI")
    rallyAutoEnabled = false
    passActive = false
    scriptActive = false
    aimLock = false
    selectedSetter = nil
    -- Disconnect FOV monitoring and restore original FOV
    if fovConnection then
        fovConnection:Disconnect()
        fovConnection = nil
    end
    if Camera then
        Camera.FieldOfView = originalFOV
    end
    -- Clean up state manager UI
    if stateManagerGui then
        stateManagerGui:Destroy()
        stateManagerGui = nil
    end
    -- Clean up power bar UI
    if powerBarAnimationConnection then
        powerBarAnimationConnection:Disconnect()
        powerBarAnimationConnection = nil
    end
    if powerBarGui then
        powerBarGui:Destroy()
        powerBarGui = nil
    end
    -- Note: unloopSpeed() will be called from the later terminateScript if needed
    -- For now, we'll handle speed cleanup separately if the connections exist
    if speedLoopConnection then
        speedLoopConnection:Disconnect()
        speedLoopConnection = nil
    end
    if characterAddedConnection then
        characterAddedConnection:Disconnect()
        characterAddedConnection = nil
    end
end

local function updatePassChargeMeter()
    if passActive then
        if eastSideCrytToggle and selectedSetter and selectedSetter.Character and selectedSetter.Character:FindFirstChild("HumanoidRootPart") then
            local setterPosition = selectedSetter.Character.HumanoidRootPart.Position
            local positionDiff = LocalPlayer.Character.HumanoidRootPart.Position - setterPosition
            local distance = Vector3.new(positionDiff.X, 0, positionDiff.Z).Magnitude
            PassChargeMeter.Value = calculatePassingPowerEastSideCryt(distance)
        elseif selectedSetter and selectedSetter.Character and selectedSetter.Character:FindFirstChild("HumanoidRootPart") then
            local setterPosition = selectedSetter.Character.HumanoidRootPart.Position
            PassChargeMeter.Value = calculatePassingPower(setterPosition)
        else
            PassChargeMeter.Value = 90 -- previous: 80
        end
    end
end

-- Fire pass remote event (like crytimperium)
local function FirePassRemote(showPowerBarUI: boolean?)
    if selectedSetter and selectedSetter.Character and selectedSetter.Character:FindFirstChild("HumanoidRootPart") then
        local playerPos = LocalPlayer.Character.HumanoidRootPart.Position
        local setterPos = selectedSetter.Character.HumanoidRootPart.Position
        
        -- Calculate direction (same as crytimperium: player to setter with Y offset)
        local direction = (setterPos - playerPos + Vector3.new(0, 20, 0)).Unit
        
        -- Get power from PassChargeMeter (already calculated by updatePassChargeMeter)
        local passPower = PassChargeMeter.Value
        
        -- Show power bar UI if requested (for receives/autodives)
        if showPowerBarUI then
            showPowerBar(passPower)
        end
        
        -- Play Bump animation if not on debounce (like MechanicsClient)
        if not passDebounce and passPower > 0 then
            passDebounce = true
            -- Stop PassStance when playing Bump (like MechanicsClient)
            PassStanceAnim:Stop()
            BumpAnim:Play()
            BumpAnim:AdjustSpeed(1.5)
            
            -- Reset debounce after animation duration (matching MechanicsClient's 0.75s wait)
            task.spawn(function()
                task.wait(0.75)
                passDebounce = false
                -- Resume PassStance if still holding MouseButton2 (hold is true)
                if hold and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    local humanoid = LocalPlayer.Character.Humanoid
                    if humanoid.FloorMaterial ~= Enum.Material.Air and not LocalPlayer.Character:HasTag("APPROACHING") then
                        if not SpikeChargeMeter:GetAttribute("MaxCharge") or SpikeChargeMeter.Value < SpikeChargeMeter:GetAttribute("MaxCharge") then
                            PassStanceAnim:Play()
                        end
                    end
                end
            end)
        end
        
        -- Fire the remote
        local args = {
            [1] = direction,
            [2] = passPower
        }
        
        PassRemote:FireServer(unpack(args))
        return true
    end
    return false
end

-- Forward declaration for updateMouseButton1Blocking (will be defined later after ContextActionService)
-- This will be assigned after ContextActionService and blockMouseButton1 are defined
local updateMouseButton1Blocking = nil

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.KeyCode == Enum.KeyCode.End then
        terminateScript()
        PassChargeMeter.Value = 0
    end
end)

--------------------------------------------------------------------------------------------------------------------

-- Smooth camera locking using RenderStepped
RunService.RenderStepped:Connect(function()
    if scriptActive and aimLock and selectedSetter and selectedSetter.Character and selectedSetter.Character:FindFirstChild("HumanoidRootPart") then
        local yOffset = -15
        local setterHumanoid = selectedSetter.Character:FindFirstChildWhichIsA("Humanoid")
        if setterHumanoid and setterHumanoid.FloorMaterial == Enum.Material.Air then
            yOffset = yOffset * 2
        end

        local targetPart = selectedSetter.Character.HumanoidRootPart.CFrame * CFrame.new(0, yOffset, 0)
        local camera = workspace.CurrentCamera
        camera.CFrame = CFrame.new(camera.CFrame.Position, targetPart.Position)
    end
end)

--------------------------------------------------------------------------------------------------------------------

-- Input handling for selecting a setter
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or not scriptActive then return end

    if input.KeyCode == Enum.KeyCode.V then
        if debounce then return end -- Prevent spamming
        debounce = true

        if selectedSetter then
            selectedSetter = nil
            eastSideCrytToggle = false -- Reset eastSideCrytToggle when removing setter
        else
            local nearestPlayer = getNearestPlayer()
            if nearestPlayer then
                selectedSetter = nearestPlayer
            end
        end

        task.delay(0.5, function() -- Cooldown to prevent spam
            debounce = false
        end)
    elseif input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 then
        if aimLockEnabled and selectedSetter and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            local humanoid = LocalPlayer.Character.Humanoid
            if humanoid.FloorMaterial ~= Enum.Material.Air then
                aimLock = true -- Enable aim lock when holding left or right mouse
            end
        end
    elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
        aimLockEnabled = not aimLockEnabled -- Toggle aim lock on/off
        updateMouseButton1Blocking() -- Update MouseButton1 blocking based on new state
    elseif input.KeyCode == Enum.KeyCode.End then
        terminateScript()
    elseif input.KeyCode == Enum.KeyCode.C then
        eastSideCrytToggle = not eastSideCrytToggle
        if eastSideCrytToggle then
            previousSetter = selectedSetter
            selectedSetter = Players:FindFirstChild("EastSideCryt") or Players:FindFirstChild("defensiveprotecter") or Players:FindFirstChild("B0CRUZ") or Players:FindFirstChild("AzurePlayer1")
        else
            selectedSetter = previousSetter
        end
    elseif input.KeyCode == Enum.KeyCode.X then
        rallyAutoEnabled = not rallyAutoEnabled
    elseif input.KeyCode == Enum.KeyCode.Six then
        servingMode = not servingMode
        if servingMode then
            -- Turning serving mode ON: save current aimLock state and disable it
            aimLockStateBeforeServing = aimLockEnabled
            aimLockEnabled = false
        else
            -- Turning serving mode OFF: restore previous aimLock state
            aimLockEnabled = aimLockStateBeforeServing
        end
        updateMouseButton1Blocking() -- Update MouseButton1 blocking based on serving mode
    end
end)

-- Input handling for releasing the mouse
UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed or not scriptActive then return end

    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 then
        aimLock = false -- Disable aim lock when releasing left or right mouse
    end
end)

-- Bind updatePassChargeMeter to RenderStepped
RunService:BindToRenderStep("UpdatePassChargeMeter", Enum.RenderPriority.Last.Value, function()
    updatePassChargeMeter()
end)

-- Rally auto-activation system
local WeaponProcRemote = RSPackageFolder:WaitForChild("Remotes"):WaitForChild("Functions"):WaitForChild("WeaponProc")
local WeaponProc2Remote = RSPackageFolder:WaitForChild("Remotes"):WaitForChild("Functions"):WaitForChild("WeaponProc_2")
local lastRallyActivationTime = 0
local RALLY_ACTIVATION_COOLDOWN = 0.1 -- Minimum time between activations

local function checkAndActivateRally()
    if not rallyAutoEnabled then return end
    
    local currentTime = tick()
    if (currentTime - lastRallyActivationTime) < RALLY_ACTIVATION_COOLDOWN then return end
    
    local player = LocalPlayer
    local weapon1 = player:GetAttribute("WEAPON")
    local weapon2 = player:GetAttribute("WEAPON_2")
    
    -- Check if Rally weapon is equipped
    if weapon1 ~= "RALLY" and weapon2 ~= "RALLY" then return end
    
    local gui = player:FindFirstChild("PlayerGui")
    if not gui then return end
    
    local mainScreen = gui:FindFirstChild("MAIN_SCREEN")
    if not mainScreen then return end
    
    local controls = mainScreen:FindFirstChild("CONTROLS")
    if not controls then return end
    
    -- Determine which weapon slot has Rally and check appropriate GUI
    local weaponGui = nil
    local weaponTextGui = nil
    local remoteToUse = nil
    
    if weapon1 == "RALLY" then
        weaponGui = controls:FindFirstChild("WEAPON_1")
        remoteToUse = WeaponProcRemote
    elseif weapon2 == "RALLY" then
        weaponGui = controls:FindFirstChild("WEAPON_2")
        remoteToUse = WeaponProc2Remote
    end
    
    if not weaponGui then return end
    
    weaponTextGui = weaponGui:FindFirstChild("Weapon")
    if not weaponTextGui then return end
    
    local weaponText = weaponTextGui.Text
    
    -- If text is empty, weapon is off cooldown - activate it
    if weaponText == "" then
        lastRallyActivationTime = currentTime
        pcall(function()
            remoteToUse:InvokeServer()
        end)
    end
end

-- Bind Rally check to RenderStepped
RunService:BindToRenderStep("CheckRallyAuto", Enum.RenderPriority.Last.Value, function()
    checkAndActivateRally()
end)


--------------------------------------------------------------------------------------------------------------------

function ball()
    local target = nil
    local minDistance = math.huge
    local localPlayer = game.Players.LocalPlayer
    local ballFolder = workspace.BallFolderServer

    for _, b in pairs(ballFolder:GetChildren()) do
        if b:IsA("Model") and b:FindFirstChild("Ball") then
            local ballPosition = b.Ball.Position
            local playerDistance = localPlayer:DistanceFromCharacter(ballPosition)
            if playerDistance < minDistance then
                target = b.Ball
                minDistance = playerDistance
            end
        end
    end

    return target
end

--------------------------------------------------------------------------------------------------------------------

local targets = {}
local partvisual = {}

local function LANDINGPOS(velocity: Vector3, position: Vector3)
    -- This function returns the landing position (when y=0)
    -- and the velocity at that moment, or nil/nil if no real solution.

    local gravity = workspace.Gravity  -- Roblox's default ~196.2
    local vy      = velocity.Y
    local y0      = position.Y

    -- We want to solve:  0.5 * g * t^2 - vy * t - y0 = 0
    -- Let a = 0.5*g, b = -vy, c = -y0
    local a = 0.5 * gravity
    local b = -vy
    local c = -y0

    -- Discriminant
    local disc = b*b - 4*a*c
    if disc < 0 then
        -- No real solutions => never hits y=0
        return nil, nil
    end

    local sqrtDisc = math.sqrt(disc)
    local t1 = (-b + sqrtDisc) / (2 * a)
    local t2 = (-b - sqrtDisc) / (2 * a)

    -- We want the physically valid (positive) time.
    -- If both are positive, pick the larger one (the "final" landing).
    local tLanding
    if t1 >= 0 and t2 >= 0 then
        tLanding = math.max(t1, t2)
    elseif t1 >= 0 then
        tLanding = t1
    elseif t2 >= 0 then
        tLanding = t2
    else
        -- Both negative => landing was "in the past"
        return nil, nil
    end

    -- Now compute final position/velocity at tLanding
    local accel = Vector3.new(0, -gravity, 0)

    -- position(t) = position + velocity*t + 0.5*accel*t^2
    local landingPosition =
        position
        + velocity * tLanding
        + 0.5 * accel * (tLanding * tLanding)

    -- velocity(t) = velocity + accel*t
    local landingVelocity = velocity + accel * tLanding

    return landingPosition, landingVelocity
end

--[[ Example usage:
local testVelocity = Vector3.new(10, 30, 0)  -- some initial velocity
local testPosition = Vector3.new(0, 5, 0)   -- launched from y=5
local pos, vel = LANDINGPOS(testVelocity, testPosition)
if not pos then
    --warn("No real landing time found.")
else
    --print("Landing Position:", pos)
    --print("Landing Velocity:", vel)
end
]]

local function IsWithinHitbox(position, hitboxPart)
    local relativePos = hitboxPart.CFrame:PointToObjectSpace(position)
    local halfSize = hitboxPart.Size * 0.5
    -- If X, Y, Z all lie within half the part size, the position is "inside" the part bounds
    return (
        math.abs(relativePos.X) <= halfSize.X 
        and math.abs(relativePos.Y) <= halfSize.Y 
        and math.abs(relativePos.Z) <= halfSize.Z
    )
end

-- 2D footprint check on the court, with optional height gate
local function is_within_footprint_xz(pos: Vector3, box: BasePart, max_height: number?): boolean
    local rel = box.CFrame:PointToObjectSpace(pos)
    local half = box.Size * 0.5
    local within_xz = (math.abs(rel.X) <= half.X) and (math.abs(rel.Z) <= half.Z)
    if not within_xz then return false end
    if max_height then
        -- allow anything from floor up to reach height above the box center
        return rel.Y <= max_height
    end
    return true
end

local REACH_HEIGHT = 5

-- horizontal (x,z) intercept math
local function landing_time(vel: Vector3, pos: Vector3): number?
    local g = workspace.Gravity
    local a, b, c = 0.5 * g, -vel.Y, -pos.Y
    local disc = b * b - 4 * a * c
    if disc < 0 then return nil end
    local rt = math.sqrt(disc)
    local t1, t2 = (-b + rt) / (2 * a), (-b - rt) / (2 * a)
    local t = math.max(t1, t2)
    return (t >= 0) and t or nil
end

local function ball_pos_at_time(vel: Vector3, pos: Vector3, t: number): Vector3
    -- x,z linear; y parabola
    return pos + vel * t + Vector3.new(0, -0.5 * workspace.Gravity * (t * t), 0)
end

-- solve |(p_ball2d + v2d*t) - p_player2d| = player_speed * t
local function solve_ground_intercept_time(player_pos: Vector3, vel: Vector3, pos: Vector3, player_speed: number): number?
    local p2 = Vector2.new(pos.X, pos.Z)
    local v2 = Vector2.new(vel.X, vel.Z)
    local pp = Vector2.new(player_pos.X, player_pos.Z)

    local r = p2 - pp
    local a = v2:Dot(v2) - (player_speed * player_speed)
    local b = 2 * r:Dot(v2)
    local c = r:Dot(r)

    local eps = 1e-6
    if math.abs(a) < eps then
        if math.abs(b) < eps then return nil end
        local t = -c / b
        return (t > 0) and t or nil
    end

    local disc = b * b - 4 * a * c
    if disc < 0 then return nil end
    local rt = math.sqrt(disc)
    local t1 = (-b - rt) / (2 * a)
    local t2 = (-b + rt) / (2 * a)

    local best = math.huge
    if t1 > 0 then best = math.min(best, t1) end
    if t2 > 0 then best = math.min(best, t2) end
    return (best ~= math.huge) and best or nil
end

-- main helper: returns intercept position + time, clamped before landing
local function compute_intercept_pos(player_pos: Vector3, vel: Vector3, pos: Vector3, player_speed: number)
    local t_land = landing_time(vel, pos)
    if not t_land then return nil, nil end

    local t = solve_ground_intercept_time(player_pos, vel, pos, player_speed)
    if not t then return nil, nil end

    if t > t_land then t = t_land end -- never after the bounce/land
    local p = ball_pos_at_time(vel, pos, t)

    -- keep it slightly above floor so the visualizer isnâ€™t z-fighting
    if p.Y < 1.25 then p = Vector3.new(p.X, 1.25, p.Z) end
    return p, t
end

--------------------------------------------------------------------------------------------------------------------

local debounce = false
local bounce = false
local runLoop

local part = Instance.new("Part")
part.Size = Vector3.new(2.3, 2.3, 2.3)
part.Shape = Enum.PartType.Ball
part.Anchored = true
part.Parent = workspace
part.Transparency = 0.3
part.Material = Enum.Material.Neon
part.CanCollide = false
local currentTHit = nil
local currentBallVelocityMagnitude = nil
runLoop = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
    -- use cached local references instead of WaitForChild in the loop
    local players = game:GetService("Players")
    local localPlayer = players.LocalPlayer
    local localmodel = LocalModel
    local spike = SpikeChargeMeter

    if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
        if localPlayer.Character.Humanoid.FloorMaterial == Enum.Material.Air then
            spike.Value = 500
        else
            spike.Value = 0
        end
    end

--[[
    game:GetService("Players").LocalPlayer.PlayerScripts.Stamina.Value = 100
    if getnearest() ~= nil and not readjusting then
        local distance = getnearest()
        local value = 0.936501 * distance + 33.02382
        if value < 10 then
            value = 10
        end

        localmodel.PassChargeMeter.Value = value
    end
]]

--------------------------------------------------------------------------------------------------------------------

    -- Manage PassStance animation based on conditions (like MechanicsClient)
    if hold and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
        local humanoid = LocalPlayer.Character.Humanoid
        if humanoid.FloorMaterial == Enum.Material.Air or LocalPlayer.Character:HasTag("APPROACHING") then
            -- Stop PassStance when in air or approaching
            PassStanceAnim:Stop()
        elseif not PassStanceAnim.IsPlaying then
            -- Resume PassStance if conditions are met and not already playing
            if not SpikeChargeMeter:GetAttribute("MaxCharge") or SpikeChargeMeter.Value < SpikeChargeMeter:GetAttribute("MaxCharge") then
                PassStanceAnim:Play()
            end
        end
    end

    -- Fire pass remote continuously when MouseButton1 is held OR within 0.3s after release (if aimLockEnabled and not serving mode)
    if not servingMode then
        local currentTime = tick()
        local timeSinceRelease = currentTime - mouseButton1ReleaseTime
        local shouldFireRemote = (mouseButton1Held or (mouseButton1ReleaseTime > 0 and timeSinceRelease <= MOUSE_BUTTON_1_POST_RELEASE_DURATION))
        
        if shouldFireRemote and aimLockEnabled and selectedSetter then
            FirePassRemote(true) -- Show power bar on continuous firing
        end
    end

    local b_cached = ball()
    if b_cached and autoEnabled then

        local MyDistance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - b_cached.Position).Magnitude
        local FinalPosition = LANDINGPOS(b_cached.Parent.Velocity.Value, b_cached.Position)

--------------------------------------------------------------------------------------------------------------------

        local ballPosition = b_cached.Position
        local netPosition = net.Position
        local playerPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
        
        -- Function to determine which side of the net the player is on
        local function getSideOfNet()
            
            

            -- Assuming the net is oriented along the X-axis and splits the Z-axis
            if playerPosition.Z > netPosition.Z then
                return "Right Side"
            else
                return "Left Side"
            end
        end

        -- Function to determine which side of the net the ball is on
        local function getBallSideOfNet()
      

            -- Assuming the net is oriented along the X-axis and splits the Z-axis
            if ballPosition.Z > netPosition.Z then
                return "Right Side"
            else
                return "Left Side"
            end
        end

--------------------------------------------------------------------------------------------------------------------

        local humanoidRootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
        local humanoid = game.Players.LocalPlayer.Character.Humanoid
        local originalWalkSpeed = humanoid.WalkSpeed
        local rootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
        local ballVelocity = b_cached.Parent.Velocity.Value
		local ballVelocityMagnitude = ballVelocity.Magnitude

		-- Calculate time for ball to reach FinalPosition
		if FinalPosition then
			local ball_vel = b_cached.Parent.Velocity.Value
			local ball_pos = b_cached.Position
			currentTHit = landing_time(ball_vel, ball_pos)
			currentBallVelocityMagnitude = ballVelocityMagnitude
			
			-- Visualizer
			part.Position = FinalPosition
		end

--------------------------------------------------------------------------------------------------------------------

-- (duplicate IsWithinHitbox removed; top-level version is used)

--------------------------------------------------------------------------------------------------------------------

--// Full Script

-- (Everything above here is assumed to be the same in your environment,
--  such as variable definitions for 'humanoid', 'humanoidRootPart', etc.)

local function MoveTo(POS)
    -- Check if the ball is on the same side of the net as the player
    if MyDistance <= 100 then
        -- Only set WalkSpeed once per movement session, not every frame
        if humanoid.FloorMaterial ~= Enum.Material.Air and not moveToWalkSpeedSet then
            humanoid.WalkSpeed = 40
            moveToWalkSpeedSet = true
            
            -- Clean up old connection if it exists
            if moveToWalkSpeedConnection then
                moveToWalkSpeedConnection:Disconnect()
            end
            
            -- Set up connection to reset WalkSpeed when movement stops
            moveToWalkSpeedConnection = humanoid.MoveToFinished:Connect(function(reached)
                humanoid.WalkSpeed = originalWalkSpeed
                moveToWalkSpeedSet = false
                if moveToWalkSpeedConnection then
                    moveToWalkSpeedConnection:Disconnect()
                    moveToWalkSpeedConnection = nil
                end
            end)
        end
        
        humanoid:MoveTo(POS)

        -- Check if the local player was the last to touch the ball
        local TouchCheck = true
        if TouchCheck then 
            local lastTouchPlayer = workspace.BallFolderServer.ballEntity.Player.Value
            if lastTouchPlayer == game.Players.LocalPlayer then
                -- Skip diving and camera adjustments if the local player was the last toucher
                return 
            end
        end

        if MyDistance <= 60 then -- important: farther = more computational load
			local playerSpeed = humanoid.WalkSpeed
			local playerDistanceToPOS = (POS - rootPart.Position).Magnitude
			-- prefer t_hit (time for ball to reach intercept) if available
			local timeToReachPlayer = playerDistanceToPOS / playerSpeed

            local timeToReachBall = currentTHit or math.huge

            if (currentBallVelocityMagnitude or ballVelocityMagnitude) > 30 and MyDistance <= 40 and getSideOfNet() == getBallSideOfNet() then
                -- Fire pass remote if aimLockEnabled is enabled and not in serving mode
                if not servingMode then
                    if aimLockEnabled and selectedSetter then
                        FirePassRemote(true) -- Fire remote when aimLockEnabled is true, show power bar
                    else
                        FirePassRemote(true) -- Fallback to click if aimLock not enabled or no setter, show power bar
                    end
                end
            end

			-- Only dive if you're far enough and timeToReachBall is critical
			if timeToReachBall and timeToReachBall <= timeToReachPlayer and playerDistanceToPOS > 22 and playerDistanceToPOS <= 45 then
				if (currentBallVelocityMagnitude or ballVelocityMagnitude) > 75 --[[and getSideOfNet() == getBallSideOfNet()]] and is_within_footprint_xz(POS, InHitbox, REACH_HEIGHT) then
					-- Show power bar before diving
					if selectedSetter and selectedSetter.Character and selectedSetter.Character:FindFirstChild("HumanoidRootPart") then
						showPowerBar(PassChargeMeter.Value)
					end
					
					-- Use directional dive directly to FinalPosition (animation chosen based on direction)
					if not isAnyDiveAnimPlaying() then
						performDirectionalDive(POS)
					end
                else
					humanoid:MoveTo(POS)
                end
            end
        end
    end
end

--[[ 
    local ballVelocity = ball().Parent.Velocity.Value
    local ballVelocityMagnitude = ballVelocity.Magnitude
    local rootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
    if ballVelocityMagnitude > 150 
       and (FinalPosition - rootPart.Position).Magnitude <= 30 then
        -- Check if the ball is moving super fast and is within 30 studs 
        -- of FinalPosition
        MoveTo(FinalPosition)
    end
]]

        -- Continuous pass remote firing when hold is true (like crytimperium)
        if hold and FinalPosition then
            MoveTo(FinalPosition)
            
            if not servingMode and aimLockEnabled and selectedSetter and selectedSetter.Character and selectedSetter.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - FinalPosition).Magnitude
                
                -- Check if blocked by net
                local isBlocked = false
                local parts = workspace.CurrentCamera:GetPartsObscuringTarget({FinalPosition}, {workspace.CurrentCamera, game.Players.LocalPlayer.Character})
                for _, p in ipairs(parts) do
                    if (p:IsA("Part") and p.Name == "Net") then
                        isBlocked = true
                        break
                    end
                end
                
                -- Check if within hitbox
                local withinHitbox = is_within_footprint_xz(FinalPosition, InHitbox, REACH_HEIGHT)
                
                -- Fire pass remote continuously when hold is true and conditions are met
                if distance <= 80 and withinHitbox and not isBlocked then
                    local myspeed = Vector3.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.X, 0, game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Z).Magnitude
                    if myspeed == 0 then myspeed = 1 end -- Prevent division by zero
                    local playertofinal = (FinalPosition - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    local time2reach = playertofinal / myspeed
                    local time2reachball
                    local ballVelocityMagnitude = b_cached.Parent.Velocity.Value.Magnitude
                    if ballVelocityMagnitude > 0 then
                        local balltofinal = (FinalPosition - b_cached.Position).Magnitude
                        time2reachball = balltofinal / ballVelocityMagnitude
                    else
                        time2reachball = math.huge
                    end
                    
                    -- Fire pass remote (always fires when hold is true and conditions met)
                    FirePassRemote()
                    
                    -- Also fire on dive conditions (like crytimperium)
                    if time2reachball <= time2reach and playertofinal >= 18 --[[15]] and playertofinal <= 35 then
                        if ballVelocityMagnitude > 80 and readjusting then
                            -- Show power bar before diving
                            showPowerBar(PassChargeMeter.Value)
                            
                            FirePassRemote(false) -- Fire again for dive (don't show bar twice)
                            if not isAnyDiveAnimPlaying() then
								performDirectionalDive(FinalPosition)
							end
                        end
                    end
                end
            end
        end

    end
end)

--------------------------------------------------------------------------------------------------------------------

game.UserInputService.InputBegan:connect(function(input)
    if input.KeyCode == Enum.KeyCode.End then
        pcall(function()
            if not debounce then
                terminateScript()
                runLoop:Disconnect()
                debounce = true
                rallyAutoEnabled = false
                part:Destroy()
                table.clear(targets)
                for i, v in pairs(partvisual) do
                    v:Destroy()
                end
                table.clear(partvisual)
            end
        end)
    end
end)


game.UserInputService.InputBegan:connect(function(input)
    if input.KeyCode == Enum.KeyCode.KeypadEight then
        if not debounce then
            --grid(Vector3.new(mouse.Hit.p.X, game.Players.LocalPlayer.Character.HumanoidRootPart.Position.Y - 3, mouse.Hit.p.Z), space, 25)
        end
    end
end)

game.UserInputService.InputBegan:connect(function(input)
    if input.KeyCode == Enum.KeyCode.KeypadNine then
        if not debounce then
            pcall(function()
                if not debounce then
                    table.clear(targets)
                    for i, v in pairs(partvisual) do
                        v:Destroy()
                    end
                    table.clear(partvisual)
                end
            end)
        end
    end
end)

game.UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        -- Fire pass remote when MouseButton1 is pressed (only if not in serving mode)
        if not servingMode then
            FirePassRemote(true) -- Show power bar on manual click
        end
    elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
        FirePassRemote(true) -- Show power bar on manual click
        if not debounce then
            readjusting = true
        end
    end
end)

game.UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        if not debounce then
            readjusting = false
        end
    end
end)

game.UserInputService.InputBegan:connect(function(input)
    if input.KeyCode == Enum.KeyCode.LeftAlt then
        if not debounce then
            autoEnabled = not autoEnabled
        end
    end
end)

local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")

local function blockMouseButton2(actionName, inputState, inputObject)
    if inputState == Enum.UserInputState.Begin then
        hold = true
        -- Play PassStance animation when holding right click (like MechanicsClient)
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            local humanoid = LocalPlayer.Character.Humanoid
            if humanoid.FloorMaterial ~= Enum.Material.Air and not LocalPlayer.Character:HasTag("APPROACHING") then
                if not SpikeChargeMeter:GetAttribute("MaxCharge") or SpikeChargeMeter.Value < SpikeChargeMeter:GetAttribute("MaxCharge") then
                    PassStanceAnim:Play()
                end
            end
        end
    elseif inputState == Enum.UserInputState.End then
        hold = false
        -- Stop PassStance animation when releasing right click
        PassStanceAnim:Stop()
    end
    return Enum.ContextActionResult.Sink -- Block the game from detecting the key
end

local function blockMouseButton1(actionName, inputState, inputObject)
    -- Only block and fire remote if not in serving mode
    if not servingMode then
        if inputState == Enum.UserInputState.Begin then
            mouseButton1Held = true
            mouseButton1ReleaseTime = 0 -- Reset release time when pressed again
            -- Set aimLock when MouseButton1 is pressed (if aimLockEnabled and on ground)
            if aimLockEnabled and selectedSetter and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                local humanoid = LocalPlayer.Character.Humanoid
                if humanoid.FloorMaterial ~= Enum.Material.Air then
                    aimLock = true -- Enable aim lock when holding MouseButton1
                end
            end
            -- Fire pass remote when MouseButton1 is pressed
            FirePassRemote(true) -- Show power bar on manual click
        elseif inputState == Enum.UserInputState.End then
            mouseButton1Held = false
            mouseButton1ReleaseTime = tick() -- Record release time for post-release firing
            -- Disable aim lock when releasing MouseButton1
            aimLock = false
        end
        return Enum.ContextActionResult.Sink -- Block the game from detecting the key
    else
        -- In serving mode, don't block (let game handle it)
        return Enum.ContextActionResult.Pass
    end
end

-- Bind the action to block MouseButton2 input
ContextActionService:BindAction(
    "BlockMouseButton2", -- Name of the action
    blockMouseButton2,   -- Function to call
    false,               -- Whether to allow mobile button UI (set false to block)
    Enum.UserInputType.MouseButton2 -- The key to block
)

-- Function to update MouseButton1 blocking based on aimLockEnabled and servingMode
updateMouseButton1Blocking = function()
    -- Only block MouseButton1 if aimLockEnabled is true AND servingMode is false
    if aimLockEnabled and not servingMode then
        -- Bind MouseButton1 blocking when aimLockEnabled is true and serving mode is off
        ContextActionService:BindAction(
            "BlockMouseButton1", -- Name of the action
            blockMouseButton1,   -- Function to call
            false,               -- Whether to allow mobile button UI (set false to block)
            Enum.UserInputType.MouseButton1 -- The key to block
        )
    else
        -- Unbind MouseButton1 blocking when aimLockEnabled is false or serving mode is on
        ContextActionService:UnbindAction("BlockMouseButton1")
    end
end

-- Initially set up MouseButton1 blocking based on aimLockEnabled state
updateMouseButton1Blocking()

-- Unbind the actions when the End key is pressed
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.End then
        ContextActionService:UnbindAction("BlockMouseButton2")
        ContextActionService:UnbindAction("BlockMouseButton1")
    end
end)
--------------------------------------------------------------------------------------------------------------------

local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local stamina = localPlayer:WaitForChild("PlayerScripts"):WaitForChild("Stamina")
local aliveFolder = workspace:WaitForChild("Alive Folder")
local localmodel = aliveFolder:WaitForChild(localPlayer.Name)
local jumpChargeMeter = localmodel:WaitForChild("JumpChargeMeter")
local passChargeMeter = localmodel:WaitForChild("PassChargeMeter")
local spikeChargeMeter = localmodel:WaitForChild("SpikeChargeMeter")
local ballFolder = workspace:WaitForChild("BallFolder")
local humanoid = localmodel:WaitForChild("Humanoid")

local function updateChargeMeters()
    jumpChargeMeter.Value = 10

    stamina.Value = 100
    humanoid.JumpHeight = 14.5
    workspace.Gravity = 80
end

local function updateBallSizes()
    for _, ball in ipairs(ballFolder:GetChildren()) do
        if ball:IsA("BasePart") and ball.Name == "Ball" then
            ball.Size = Vector3.new(8, 8, 8)
        end
    end
end

local function updateWalkSpeed()
    -- Don't interfere if MoveTo is controlling WalkSpeed
    if moveToWalkSpeedSet then
        return
    end
    
    local playingAnimations = humanoid:GetPlayingAnimationTracks()
    for _, animationTrack in ipairs(playingAnimations) do
        local animationId = animationTrack.Animation.AnimationId
        if animationId == "rbxassetid://17653126040" then
            humanoid.WalkSpeed = 40
            return
        end
    end
end

local function loopSpeed()
    speedLoopConnection = (speedLoopConnection and speedLoopConnection:Disconnect() and false) or humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        updateWalkSpeed()
    end)

    characterAddedConnection = (characterAddedConnection and characterAddedConnection:Disconnect() and false) or players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
        localmodel = newCharacter
        humanoid = localmodel:WaitForChild("Humanoid")
        updateWalkSpeed()
        loopSpeed()
    end)
end

local function unloopSpeed()
    speedLoopConnection = (speedLoopConnection and speedLoopConnection:Disconnect() and false) or nil
    characterAddedConnection = (characterAddedConnection and characterAddedConnection:Disconnect() and false) or nil
end

userInputService.InputEnded:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.End then
        terminateScript()
    end
end)

runService:BindToRenderStep("UpdateChargeMeters", Enum.RenderPriority.Last.Value, function()
    updateChargeMeters()
end)

runService:BindToRenderStep("UpdateBallSizes", Enum.RenderPriority.Last.Value, function()
    updateBallSizes()
end)

loopSpeed()

--------------------------------------------------------------------------------------------------------------------
-- BetterBallRender Integration (replaces game's ballrender localscript with more accurate one)
--------------------------------------------------------------------------------------------------------------------

pcall(function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("BallRender") then
        LocalPlayer.Character.BallRender.Enabled = false
    end
end)

-- BallRender (faithful, stable, no infinite yield)
-- Visual-only replacement

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local pkg = ReplicatedStorage:WaitForChild("RSPackageFolder")
local BallTemplate = pkg:WaitForChild("Ball")
local BallFolderRender = workspace:WaitForChild("BallFolderServer")

local Settings =
	pkg:WaitForChild("PlayerProfiles")
		:WaitForChild(LocalPlayer.Name)
		:WaitForChild("Settings")

-- ===== constants copied from original intent =====
local BASE_STEP = 0.05
local SMOOTH_TIME = 0.08
local SERVER_SYNC_SCALE = 0.01
local GRAV_TICK = Vector3.new(0, -1.4700001, 0)

-- ===== resolve ballSpeed ONCE (no infinite yield) =====
local ballSpeedValue = 1
do
	local bs = BallTemplate:FindFirstChild("ballSpeed")
	if not bs then
		bs = BallTemplate:WaitForChild("ballSpeed", 2)
	end
	if bs and typeof(bs.Value) == "number" and bs.Value > 0 then
		ballSpeedValue = bs.Value
	end
end

local function expAlpha(dt, tau)
	return 1 - math.exp(-dt / math.max(tau, 1e-6))
end

local function computeCFrame(pos, vel, rollZ)
	local pitch = math.rad(vel.Z / 1.5)
	local yaw = -math.atan2(-vel.Z, -vel.X)
	local roll = math.rad(rollZ + math.abs(vel.X) / 1.5)
	return CFrame.new(pos) * CFrame.Angles(pitch, yaw, roll)
end

local function handleBall(model)
	if not model:IsA("Model") or model.Name ~= "ballEntity" then
		return
	end
	if model:FindFirstChild("Ball") then
		return
	end

	local posValue = model:WaitForChild("Position")
	local velValue = model:WaitForChild("Velocity")
	local colorValue = model:WaitForChild("Color")
	local teamValue = model:FindFirstChild("Team")
	local playerValue = model:FindFirstChild("Player")

	-- visual ball
	local ball = BallTemplate:Clone()
	if Settings:GetAttribute("BALLTRAIL") == false then
		local t = ball:FindFirstChild("Trail")
		if t then t.Enabled = false end
	end
	ball.CFrame = CFrame.new(posValue.Value)
	ball.Parent = model

	-- shadow
	local shadow = Instance.new("Part")
	shadow.Name = "Shadow"
	shadow.Anchored = true
	shadow.CanCollide = false
	shadow.Transparency = 0.6
	shadow.Size = Vector3.new(1,1,1)
	shadow.BrickColor = BrickColor.new("Black")
	shadow.Parent = model

	local mesh = Instance.new("CylinderMesh")
	mesh.Parent = shadow

	-- state copied from original logic
	local simPos = posValue.Value
	local simVel = velValue.Value
	local prevVel = velValue.Value
	local freezeCounter = 0
	local lastRollZ = ball.Orientation.Z
	local usingInputDelay = false

	local conn
	conn = RunService.Heartbeat:Connect(function(dt)
		if not model.Parent then
			conn:Disconnect()
			ball:Destroy()
			shadow:Destroy()
			return
		end

		local serverPos = posValue.Value
		local serverVel = velValue.Value

		local v30 = BASE_STEP / ballSpeedValue / math.max(dt, 1e-6)
		local v31 = SERVER_SYNC_SCALE / BASE_STEP / ballSpeedValue

		if _G.serverSync then
			local nextVel = simVel + GRAV_TICK / v30

			if prevVel == serverVel and (serverPos.Y >= 2 or serverVel.Magnitude >= 5) then
				freezeCounter += 1
			else
				freezeCounter = 0
			end
			prevVel = serverVel

			local nextPos
			if freezeCounter > 15 then
				nextPos = simPos + nextVel * (BASE_STEP / v30)
				simPos = nextPos
				simVel = nextVel
			else
				nextPos = serverPos + nextVel * (BASE_STEP / v30)
				simPos = serverPos
				simVel = serverVel
			end

			local targetPos = nextPos + nextVel * (BASE_STEP * v31 * 0.3)
			local targetCF = computeCFrame(targetPos, serverVel, lastRollZ)
			ball.CFrame = ball.CFrame:Lerp(targetCF, expAlpha(dt, SMOOTH_TIME))

		else
			local hasDelay = model:HasTag("INPUTDELAY")
			local isOpponent = false

			if teamValue and playerValue and teamValue.Value and playerValue.Value then
				if ((LocalPlayer.Team and LocalPlayer.Team ~= teamValue.Value) or LocalPlayer.Neutral)
					and LocalPlayer ~= playerValue.Value then
					isOpponent = true
				end
			end

			if hasDelay and isOpponent then
				usingInputDelay = true
				local delayedPos = serverPos - serverVel * 0.1
				local targetCF = computeCFrame(delayedPos, serverVel, lastRollZ)
				ball.CFrame = ball.CFrame:Lerp(targetCF, expAlpha(dt, SMOOTH_TIME))

			elseif usingInputDelay then
				usingInputDelay = false
				ball.CFrame = CFrame.new(serverPos)

			else
				local stepScale = dt / BASE_STEP
				local forward = serverVel * (0.04 * stepScale)
				local targetCF = computeCFrame(serverPos + forward, serverVel, lastRollZ)
				ball.CFrame = ball.CFrame:Lerp(targetCF, expAlpha(dt, SMOOTH_TIME))
			end
		end

		lastRollZ = ball.Orientation.Z

		-- shadow visuals
		shadow.CFrame = CFrame.new(ball.Position.X, 0.33, ball.Position.Z)
		local y = ball.Position.Y
		shadow.Transparency =
			math.min(math.max((math.max(y - 17, 0) * 0.4 / 35 + 0.6), 0.6), 0.9)

		local h = math.min(math.max(y, 1) * 0.5, 60)
		mesh.Scale = Vector3.new(h, 0.01, h)

		local trail = ball:FindFirstChild("Trail")
		if trail then
			trail.Color = ColorSequence.new(colorValue.Value)
		end
	end)
end

BallFolderRender.ChildAdded:Connect(handleBall)
for _, b in ipairs(BallFolderRender:GetChildren()) do
	handleBall(b)
end
